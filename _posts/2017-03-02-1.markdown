---
layout: post
title:  "【oracle】NESTED LOOPSとHASH JOIN"
date:   2017-03-02 16:24:23
categories: oracle
tags: featured
image: /assets/article_images/desktop.jpg
---
※2017年に書いたものを2022年に移したものです。

　当時は確か10gを使っていたと思います。

### ネステッド・ループ結合(NESTED LOOPS)

名前の通りループがネストして結合していく。

実行計画を見た時はこんな感じで出してくれてる。

▽SELECT STATEMENT

　▽NESTED LOOPS

```SQL
SELECT *
FROM   table1 A
    ,  table2 B
WHERE  A.xxx_id = 111
AND    A.xxx_id = B.xxx_id
```

としたとき、Aテーブルの1行ずつに対して111かどうかを確認し（外側ループ：駆動表）、111が当たればBテーブルに対して111を探しに行く（内側ループ：内部表）。

イメージはこちら。
```
for (A.xxx_idをぐるぐる) {   //OUTER LOOP
  if (A.xxx_id == 111) {
    for (B.xxx_idをぐるぐる) { //INNER LOOP
      if (A.xxx_id == B.xxx_id) {
        return
      }
    }
  }
}   //文字通りこんな感じでループがネストしてるイメージ
```
### ネステッドループのチューニングにあたり

- 駆動表を小さくする。

　当然だが駆動表が小さいほどネステッド・ループの性能がいいとされる。ただし、現在では基本的にオプティマイザが駆動表の選択をする。

  * 表が小さいものは駆動表

  * 索引参照を実行できる表は内部表

  * 重複項目が最も少ない表は駆動表

  となりやすいらしい。

- 内部表になりうるテーブルにインデックスを貼る

　INDEXが無いと、単純にBテーブルの列数分ループが必要になる。

　内部表が結合キーで一いにならないとINDEXを貼っていても限定範囲であるもののループが残る。


### ハッシュ結合(HASH JOIN)

ハッシュ値を元行う関係上、等価結合（=）の場合のみハッシュ結合が使用可能。

実行計画を見た時はこんな感じで出してくれてる。

▽SELECT STATEMENT

　▽HASH JOIN

オプティマイザが小規模表だと見積もった表からHASH表をメモリ上に作成。

メモリ上に収まらない場合はストレージを使用するため遅延が生じる（TEMP落ち）

#### ハッシュ結合のチューニング...?

- メモリ上にハッシュテーブルを作成するため、メモリ消費が激しい（対ネステッド・ループ）

- 最短でも結果を返すのは、小規模表をすべて読み込みハッシュテーブルに変換してから

- なので基本的にはネステッドループ結合が苦手とする場合はハッシュ結合を選択する。

　ネステッドループ苦手分野（オプティマイザ判断）

  * 適切な駆動表が存在しない

  * 駆動表が存在しても内部表のヒット件数が多い（≒内部表にINDEXが存在しない）

なので、等価条件でアクセス対象のデータが多いものはハッシュ結合が選択されがち。チューニングの話からそれてしまった。

オプティマイザが優秀なのでなかなか使わないが、実行計画を誘導したい場合はUSE_HASHを指定してあげると上手く行く。

### 共通

実行計画上、TABLE ACCESS FULLを見かけたら言わずもがな。

テーブルに対してすべての行を取得してるため非効率。INDEX貼ったりして対策すべき。
